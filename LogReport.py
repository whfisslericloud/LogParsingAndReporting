"""
LogReport.py

A program that parses all logs in a given path, and outputs results (into csv files) for the following:
- Machine (system) information
- Memory usage statistics
- LogSpam
- Hitch occurances and statistics 
- Error ocurrances and callstacks
- Unit test results for the parsing operations 

Uses log files generated by CreateArbitraryLog.py as data source/s.

William Fissler 2023

""" 

import logging, os, datetime, platform, glob, re, csv, time

"""
class for handling all parsing of criteria from logging and caching it for future use
"""

# create log file for this script
# function is independent of subsequent classes
def createLogFile():
    try: 
        timestamp = str(datetime.datetime.now())
        timestamp = timestamp.replace(" ","_")
        timestamp = timestamp.replace(":",".")
        logName = "LogReport_"+timestamp+".log"
        
        if platform.system() == "Windows":
            logPath = 'Logs"\"'
        else:
            logPath = "Logs/"
        
        logging.basicConfig(filename=logPath + logName, encoding='utf-8', level=logging.DEBUG)   
    except Exception as e:
            logging.exception(e)

class LogParser:
    
    def __init__(self) -> None:
        self.hitchList = []
        self.memoryList = []
        self.errorList = []
        self.logSpamList = []
        self.systemInfoList = []
        self.hitchCriteria = "Hitch"
        self.memoryCriteria = "memory footprint"
        self.errorCriteria = "Error"
        self.startTime = time.time() 
    
    # displays and logs statistics for runtime information 
    def printFinalStats(self):
        try: 
            elapsedTime = str(round(time.time()-self.startTime,2))
            print("Total Execution Time: " + elapsedTime + " seconds")
            logging.info("Total Execution Time: " + elapsedTime + " seconds")
        except Exception as e:
                logging.exception(e)

    # get logs from log path and cache for future iteration
    def cacheLogs(self):
            
        try:
            logCache = []
            logging.info("Current working directory is: " + os.getcwd())
            
            if os.path.exists("Logs"):  
                          
                os.chdir("Logs") #set working directory to log storage location before caching logs
                logging.info("Current working is set to: " + os.getcwd())
                
                for file in glob.glob('CreateArbitraryLog*.log'):
                    index = 0
                    logCache.append(file) 
                    logging.info("Found Log: " + file)
                    index += 1        
        except Exception as e:
            logging.exception(e)
            
        return logCache

    # iterate through log file/s and search for criteria
    # write criteria matches to respective CSV
    def iterateLogs(self,logCache):
        try:           
            if len(logCache) != 0: # check to see if cache is empty 
                               
                doWriteHeader = True # only write header on first time write to CSV 
                logCount = 0 # to track how many logs have been iterated through   
                                                
                for log in logCache:      
                                  
                    lineNumber = 1 # current to track line number being parsed       
                                
                    with open(log) as cachedLog:  
                        while True:
                               
                            line = cachedLog.readline()
                            
                            if not line: # check if end of file
                                logging.info("Finished processing file: " + str(logCount+1) + "/" + str(len(logCache)) + " : " + log)
                                lineNumber = 0 # reset line number at end of file
                                break
                            else:
                                if re.search(self.hitchCriteria, line) is not None:
                                    line = log + " - " + line + " at line number: " + str(lineNumber)
                                    self.hitchList.append(line)
                                    logging.info("Hitch data found on line " + str(lineNumber))                                
                                elif re.search(self.memoryCriteria, line) is not None:
                                    line = log + " - " + line + " at line number: " + str(lineNumber)
                                    self.memoryList.append(line)
                                    logging.info("Memory data found on line " + str(lineNumber))
                                else:
                                    logging.info("No hitch or memory data found on line " + str(lineNumber)) 
                                    
                            lineNumber += 1 # increment line number before evaluating next log line
                    logCount += 1 # increment number of files processed before evaluating next log file
            else:
                logging.warning("Log Cache is Empty!")                
        except Exception as e:
            logging.exception(e)
            
"""
class for handling all CSV file related operations 
""" 
class CSVWriter:
    
    def __init__(self) -> None:
        pass #placeholder until properties are established
    
    # check for preexisting file, increment file number and return name of first non-duplicate
    def checkForExistingFile(self, fileName):
        
        try:   
            fileDupeNum = 0 
            
            if fileName == "HitchReport.csv":                        
                while os.path.isfile(fileName):
                    fileDupeNum += 1
                    fileName = "HitchReport("+str(fileDupeNum)+").csv"
                    logging.info(fileName + "already exists")
            elif fileName == "MemoryReport.csv":
                while os.path.isfile(fileName):
                    fileDupeNum += 1
                    fileName = "MemoryReport("+str(fileDupeNum)+").csv"
                    logging.info(fileName + "already exists")
            else:
                print(fileName + " is and invalid file name for csv creation")
                logging.error(fileName + " is and invalid file name for csv creation")
                                    
            logging.info("Creating CSV file: " + fileName)
            return fileName
        except Exception as e:
            logging.exception(e)

    def writeMemoryFootprintToCSV(self, memoryList):
    
        try: 
            if len(memoryList) != 0:
                 with open(self.checkForExistingFile("MemoryReport.csv"), 'w', newline='', encoding='utf-8') as csvfile:
                    writer = csv.writer(csvfile, delimiter='\t', quoting=csv.QUOTE_NONE, escapechar='\n')
                    header = ["Log Name", "Log Line", "Footprint (MiB)", "Time Recorded"]
                    writer.writerow(header)
                    
                    for line in range(len(memoryList)):
                        logName = (re.search(r"([^\s]+)", memoryList[line])).group()
                        newLine = memoryList[line].strip(logName)       
                        lineNumber = (re.search(r"\d+$", memoryList[line])).group()                   
                        footprint = (re.search(r"footprint:\s(\d+\.\d+)",newLine)).group().strip("footprint: ")               
                        timeRecorded = (re.search(r"run time:\s(\d+\.\d+)",memoryList[line])).group().strip("run time: ")              
                        row = [logName, lineNumber, footprint, timeRecorded]
                        writer.writerow(row) 
            else:
                logging.warning("Failure to write Memory Report. Memory List is empty")            
                        
        except Exception as e:
            logging.exception(e)                   
    
            
    def writeHitchToCSV(self, hitchList):        
        try: 
            if len(hitchList) != 0:                
                with open(self.checkForExistingFile("HitchReport.csv"), 'w', newline='', encoding='utf-8') as csvfile:
                    writer = csv.writer(csvfile, delimiter='\t', quoting=csv.QUOTE_NONE, escapechar='\n')
                    header = ["Log Name", "Log Line", "Thread", "Duration (ms)"]
                    writer.writerow(header)
                    
                    for line in range(len(hitchList)):
                        logName = (re.search(r"([^\s]+)", hitchList[line])).group()
                        newLine = hitchList[line].strip(logName)       
                        lineNumber = (re.search(r"\d+$", hitchList[line])).group()                   
                        hitchDuration = (re.search(r"duration of:\s(\d+\.\d+)",hitchList[line])).group().strip("duration of: ") #duration require log name to be stripped so that only one set of decimal numbers exist              
                        threadName = (re.search(r'thread:\s\[(.+?)\]',hitchList[line])).group().strip("thread: ").strip("[]")          
                        row = [logName, lineNumber, threadName, hitchDuration]
                        writer.writerow(row) 
            else:
                logging.warning("Failure to write Hitch Report.csv: Hitch List is empty")
        except Exception as e:
            logging.exception(e)
            
    # def writeLogSpamToCSV():
    
    # def writeErrorsToCSV():
        
    
        
    # class DuplicateLogs:
        
    #     def __init__(self, name, line, lineNumber) -> None:
    #         self.name = name
    #         self.duplicateLine = line
    #         self.lineNumberList = []
    #         self.lineNumberList.append(lineNumber)
    
    #     def setDuplicateLogging(self, line, linenumber):
            
    #         if self.duplicateLine is not None:
    #             self.duplicateLine = line
    #         elif self.duplicateLine == line:
    #             self.lineNumberList.append(linenumber)
            
    #     def getDuplicateLogList(self):
    #         duplicateLogList = (self.duplicateLine, self.lineNumberList)
    #         return duplicateLogList           
        
    
   
            
    # cache criteria to find duplicates

    # store matched criteria in a formatted CSV
    
def main():
    
    createLogFile()
    
    # instantiate objects
    objCSVWriter = CSVWriter()    
    objLogParser = LogParser()

    # gather data
    objLogParser.iterateLogs(objLogParser.cacheLogs())
    
    # perform write opertations
    objCSVWriter.writeHitchToCSV(objLogParser.hitchList)
    objCSVWriter.writeMemoryFootprintToCSV(objLogParser.memoryList)

    objLogParser.printFinalStats()
    
if __name__ == "__main__":
    main()